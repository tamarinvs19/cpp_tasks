# Домашнее задание №2 (`HW #2 (XO)`)

## Содержание
1. [Содержание](#содержание)
1. [Задание](#задание)
1. [Требования к корректности решения](#требования-к-корректности-решения)
    1. [Базовые требования](#базовые-требования)
    1. [Требования к промежуточной попытке](#требования-к-промежуточной-попытке)
    1. [Правила игры](#правила-игры)
    1. [Текстовый интерфейс](#текстовый-интерфейс)
    1. [Структура программы](#структура-программы)
    1. [Автотестирование](#автотестирование)
    1. [Структура тестов](#структура-тестов)
    1. [Структура репозитория](#структура-репозитория)
1. [Бонусное задание](#бонусное-задание)
1. [Сроки сдачи](#сроки-сдачи)
1. [Система оценки](#система-оценки)

## Задание

Реализуйте приложение-игру крестики-нолики 10 на 10 (5 в ряд) по принципу _Модель—Отображение_ (_Model—View_).
Отображение реализует текстовый интерфейс на основе _stdio_.
Реализовуйте автотесты для модели.

## Требования к корректности решения
### Базовые требования
В этом задании действуют [стандартные](../tasks-common).
В рамках задания также потребуется реализовать авто-тесты (смотри ниже).
Собранная программа с тестами должна называться `test_board`.

### Требования к промежуточной попытке
К промежуточной попытке должно быть:
* Корректно реализовано отображение (`StdioBoardView`),
* Модель реализована, но возможно без обработки всех крайних случаев (`Board`),
* Автотесты не требуются, но крайне рекомендуются.

### Правила игры
Игра ведется на игровом поле — квадрат 10 на 10 клеток.
Один игрок играет крестиками, второй — ноликами.
Первыми начинают _нолики_.
Игроки ходят по очереди.
В свой ход игрок может поставить на свободную клетку свой знак.
Целью игры является выставить 5 своих знаков в ряд по вертикали, горизонтали или любой из диагоналей.
Выигрывает тот игрок, который сделает это первым.
Если свободных клеток на игровом поле  не осталось, то назначается ничья.

### Текстовый интерфейс
Интерфейс должен быть реализован на основе _stdio_.

В начале каждого хода выводится игровое поле и приглашение: `X move:` — для крестиков и `O move:` — для ноликов (нолики обозначаются буквой «O»).
В ответ на приглашение пользователь должен ввести параметры хода — два числа (строка и столбец, числа от 0 до 9) через пробел.
Если введен некорректный ход (например,  некорректный формат чисел, клетка занята и т.д.), то выводится сообщение `Bad move!`, затем ход запрашивается повторно (приглашение выводится еще раз, доску выводить не нужно).
Также пользователь в ответ на приглашение может ввести два числа -1 и -1, что означает досрочный выход из игры.

Если после хода партия закончилась, то на экран выводится (после игрового поля) один из результатов игры: `X wins!`, `O wins!` или `Draw.`.

По умолчанию в начале каждого хода на экран выводится игровое поле.
Если задан параметр командной строки `silent`, то игровое поле выводится только один раз после окончания игры (перед надписью с результатом игры).
Доска должна вводится в виде строк из символов, описывающих клетки (`X` — буква «X», крестик; `O` — буква «O», нолик; `.` — точка, незанятая клетка), например:
```
XXXX.....O
XOXOXOXOXO
X........O
O........X
OXOXOXOXOX
XXXX.....O
XOXOXOXOXO
X........O
O........X
OXOXOXOXOX
```

Пример партии. Обратите внимание на переводы строк и пробелы.

|Ввод|Вывод|
|:---|:----|
| |`​` _(здесь и далее: пустая строчка)_<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`O move:` _(здесь и далее без перевода строки)_|
|`1 1`|`​`<br/>`..........`<br/>`.O........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`X move:`|
|`0 0`|`​`<br/>`X.........`<br/>`.O........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`O move:`|
|`0 0`|`Bad move!`<br/>`O move:`
|`1 0`|`​`<br/>`X.........`<br/>`OO........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`O move:`| 
|`0 1`| _ходы опущены_
|_ходы опущены_|`​`<br/>`XXXX......`<br/>`OOOO......`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`O move:`|
|`1 4`|`​`<br/>`XXXX......`<br/>`OOOOO.....`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`..........`<br/>`O wins!` _(с переподом строки)_|

Доступна [запись работы в терминале](https://asciinema.org/a/xUrsyAeHAXQUBiDXlK1eC0qNE) для этого примера.
Также эту запись можно просмотреть с помощью команды `asciinema play cli-demo.asciinema`.
На записи также есть демонстрация режима `silent`.

### Структура программы

* Модель представлена классом `Board`, описывает логику игры и её внутреннее представление.
  Она реализована в файлах `Board.hpp` и `Board.cpp`.
* Отображение представлено классом `StdioBoardView` и описывает текстовый интерфейс.
  Оно реализовано в `StdioBoardView.hpp` и `StdioBoardView.cpp`.
* Отображение принимает и хранит ссылку на модель.
* В классы можно добавлять свои методы.
* Вместо `XXX`/`YYY` необходимо использовать перечисления (`enum`), которые описывает фигуру/текущее состояние игры.
* Точка входа реализована в `main.cpp`.

```cpp
class Board {
public:                                  
    /** Проверить ход на корректность, если бы он был следующим. */
    bool canMove(int x, int y, XXX sign);
    /** Сделать ход. UB если он некорректен. */
    void move(int x, int y, XXX sign);
    /** Состояние игры: игра идёт, игра кончилась с одним из результатов: ничья, победа одной из сторон. */
    YYY getState();
    
    //Можно добавлять методы при необходимости.
};
```
```cpp
class StdioBoardView {
public:
    StdioBoardView(Board &board);
    /** Основной цикл игры, от начала до конца. */
    void doGameCycle();

    //Можно добавлять методы при необходимости.
};
```

### Автотестирование 

Поскольку автотестирование будет пригождаться и в будущем, требуется реализовать базовый функционал, на основе которого будут писаться тесты.
Реализуйте базовый класс `Test`, который будет являться родителем для конкретных тестовых классов:
```cpp
class Test {
protected:
    static int failedNum; // количество тестов, которые сломались
    static int totalNum;  // общее количество тестов
                                                                
    /** Проверяет условие на верность (expr). 
        Сообщает об результате пользователю, в случае неудачи подробно сообщает об источнике. */
    static void check(bool expr, const char *func, const char  *filename, size_t lineNum); 

public:
    static void showFinalResult();
    
    /** Запускает все тесты в конкретном наборе тестов */
    virtual void runAllTests() =0;

    // Можно добавлять методы при необходимости 
};
```

Каждый публичный метод класса `Board` должны быть протестирован как минимум тремя тестовыми методами класса `BoardTest` (три теста на один метод/функцию).

Пользоваться функцией check довольно неудобно, программисту приходится каждый раз вручную указывать имя файла, имя функции и номер строки.
Для того, чтобы избавить программиста от этой рутины, необходимо реализовать макрос препроцессора `DO_CHECK`,
который использует команды препроцессора (`__FILE__`, `__FUNC__`, `__LINE__`) и делает следующую подстановку:
```cpp
DO_CHECK(EXPR) → check(EXPR, __FUNC__, __FILE__, __LINE__);
```

Пример автотеста для модели `Board`.
Тестовые методы приведены в качестве примера.
```cpp
class BoardTest : public Test {
private:
    void testIsWin() {
        Board b;
        b.move(0, 0, 1);
        b.move(0, 1, 1);
        b.move(1, 0, 1);
        b.move(4, 5, 0);
        b.move(5, 5, 0);
        DO_CHECK(b.IsWin() == GAME_IN_PROGRESS);
    }
    
    void testMove1() {
        Board b;
        b.move(0, 0, 1);
        DO_CHECK(b.canMove(0, 0, 0) == false);
    }
    
    void testMove2() {
        Board b;
        m.move(0, 0, 1);
        DO_CHECK(b.canMove(1, 1, 1) == true);
    }
    
    // ...
    
public:
    void runAllTests() {
        testIsWin();
        testMove1();
        testMove2();
        // ...
    }

    // ...
};
```

Пример `test.cpp`:
```cpp
int main() {
    BoardTest bt();
    bt.runAllTests();
    Test::showFinalResults();
    return 0;
}
```

### Структура тестов

* Все файлы реализации тестов должны находиться в подпапке `test` в противовес `src`.
* Заголовочные файлы лежат в общем `include`.
* Базовый класс тестов `Test` должен быть реализован в `Test.hpp` и `Test.cpp`.
* Тесты модели `BoardTest` должны быть реализованы в `BoardTest.hpp` и `BoardTest.cpp`.
* Точка входа тестов должна быть в `test.cpp`.

### Структура репозитория
```
<корень-личного-репозитория>
|--hw_02
   |--include
   |  |-- Board.hpp
   |  |-- BoardTest.hpp
   |  |-- ...
   |--src
   |  |-- Board.cpp
   |  |-- main.cpp
   |  |-- ...
   |--test
   |  |-- BoardTest.cpp
   |  |-- test.cpp
   |  |-- ...
   |--Makefile
```

Цели в `Makefile` в соотвествии с общими требованиями:
* `all`, `hw_02`: собирает основное приложение;
* `test_board`: собирает тесты в `test_board`;
* `clean`.

## Бонусное задание
Реализуйте ещё одно отображение, класс `NcursesBoardView` в `NcursesBoardView.hpp` и `NcursesBoardView.cpp`.
Оно должно работать на основе библиотеки New Curses (`ncurses`, пакет в Ubuntu: `libncurses5-dev`).
По умолчанию программа использует класс `StdioBoardView`, но если задан параметр командной строки `curses`, то подключается `NcursesBoardView`.

В отличии от варианта на _stdio_, игровое поле все время перерисовывается на одном и том же месте.
Формат вывода игрового поле в целом такой же как и у StdioBoardView.
Ход осуществляется с помощью клавиш управления: влево, вправо, вверх, вниз и пробел (поставить крестик или нолик).
Клавиша `x` — досрочный выход из программы.
Управление должны быть устроено таким образом, чтобы нельзя было выйти за пределы доски или ввести некорректный ход.
При этом никаких сообщений об ошибке на экран не выводится.
Сообщение о результате партии должно быть такое же как и у `StdioBoardView`.

Здесь специально нет точных указаний, что сделать, вам даётся свобода.
Сделайте как вам покажется удобным, _но не заигрывайтесь_. 

## Сроки сдачи
Задание выдано 02.12.2019 (понедельник).
На задание даётся **ровно три** попытки сдачи со следующими сроками сдачи:

1. **07.12.2019 (суббота) 22:59 по Москве**.
1. **11.12.2019 (среда) 22:59 по Москве** — промежуточный срок сдачи.
1. **14.12.2019 (суббота) 22:59 по Москве** — крайний срок сдачи
   (требуется выполнить [требования к промежуточной попытке](#требования-к-промежуточной-попытке),
   чтобы получить возможность сдавать до крайнего срока).

Учтите, что в отличие от лабораторных:

* Это домашнее задание больше по сложности и объёму кода.
  Пожалуйста, не откладывайте даже до второго срока сдачи.
* Вы можете сделать **не больше трёх** полноценных попыток за всё время сдачи.
  На усмотрение преподавателя могут добавляться промежуточные попытки,
  которые будут проверяться частично.
* Вам требуется корректно выставлять и обновлять поле `Version` в тикете в зависимости
  от номера попытки сдачи.
  Полноценная проверка начинается только после увеличения поля `Version`.
* Из-за объёма кода решения могут проверяться с существенной
  задержкой, особенно при наличии стилистических замечаний.

## Система оценки

* Задание оценивается в 30 баллов: 20 за корректность, 10 за стиль.
* Вы можете получить ещё +10 баллов за [бонусное задание](#бонусное-задание), итого 40.
