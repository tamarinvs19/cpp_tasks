# Общие требования к лабораторным и домашим работам

## Структура решения

* Решение должно находиться в отдельной папке в вашем репозитории.
  * Для лабораторных приняты названия `lab_XX`, а для домашних — `hw_XX`, где `XX` — номер задания.
* В папке с решением должен находиться `Makefile` со всеми необходимыми правилами для сборки с помощью `make`.
* Все файлы решения и артефакты сборки должны находиться в правильных местах.
  * Все исходные файлы C/C++ должны находиться в подпапке `src/`.
  * Все заголовочные файлы C/C++ должны находиться в подпапке `include/`.
  * Все объектные файлы (при сборке) должны находиться в подпапке `obj/`.
  * Собранная программа (при сборке) должна находиться в корне папки задания.
* В репозитории не должны быть сохранены любые артефакты сборки и тестирования, включая папку `obj/`, все объектные файлы в ней и непосредственно исполняемый файл программы.
* Допускается, если вы написали свои тесты, чтобы они собирались в отдельную программу `test`. В некоторых заданиях автотесты являются обязательными, и могут даже и являться основной программой.
  * Тесты должны проверять корректность без вмешательства пользователя (то есть никаких дополнительных проверок глазами).
  * Тесты должны быть такими, чтобы отличить некоторую некорректную реализацию от корректной (то есть если тест всегда выполняется или не выполняется, то это плохой тест).
  * Если вы написали тесты, решение обязано их проходить.

### Пример:

В репозитории хранятся:
```
ваш-репозиторий/
|-> lab_00/
    |-> include/
    |   |-> sample.h
    |-> src/
    |   |-> sample.c
    |   |-> main.c
    |   |-> test.c
    |-> Makefile
```
После полной сборки командой `make`, `make all` или `make lab_00 test`:
```
|-> lab_00/
    |-> include/
    |   |-> sample.h
    |-> src/
    |   |-> sample.c
    |   |-> main.c
    |   |-> test.c
    |-> obj/
    |   |-> sample.o
    |   |-> main.o
    |   |-> test.o
    |-> lab_00
    |-> test
    |-> Makefile
```
После очистки командой `make clean` репозиторий возвращается в исходное состояние.

## Сборка

* `Makefile` должен быть корректен.
  * `make`, `make all` и `make lab_XX` должны собирать исполяемый файл программы. Программа называется так же, как и папка.
  * `make clean` должен удалять все созданные при сборке файлы и папки. Команда должна всегда успешно работать, даже если репозиторий уже чист.
  * Правила должны быть корректными, для этого корректно указывайте зависимости:
    * Повторное обращение для сборки любого файла (промежуточного или конечного) вроде `make obj/main.o` без влияющих на него изменений не должна приводить к исполнению каких-либо команд.
    * Если же изменения появлияли на файл, то для его перекомпиляции требуется выполнить минимальное количество команд.
    * В частности, требуется прописывать зависимости от заголовочных файлов.
    * В частности, папка `obj` должна быть прописана как order-only зависимость для объектных файлов и только для них.
* Компилятор должен вызываться либо как `gcc`/`$(CC)` (для Си), либо как `g++`/`$(CXX)` (для C++).
  Запрещается явно прописывать путь до компилятора, вроде `/usr/bin/gcc`.
* При компиляции обязательны флаги `-Wall -Wextra -Werror`.

## Структура кода

* Каждому файлу реализации (`.c`/`.cpp`), если он что-то предоставляет для других файлов, должен соотвествовать его заголовочный файл с таким же именем (`.h`/`.hpp`).
* Заголовочный файл должен содержать минимальный набор директив препроцессора, объявлений и определений, покрывающий всё предоставляемое соотвествующим файлом реализации (`.c`/`.cpp`). Не включайте в заголовочный файл конструкции, необходимые лишь в файле реализации.
* Заголовочный файл должен быть защищён от повторной вставки (*include guards*).
* Заголовочные файлы решения должны подключаться без относительного пути (`#include "../include/a.h"` запрещён).

## Поведение кода

* Программа, выделяющая динамическую память, обязана её освободить к завершению (кроме аварийных завершений, если разрешено заданием), обязана не допускать утечек.
* Запрещается использовать конструкции, которые допускают выход за пределы буферов и прочий undefined behavior.
  * Например, при чтении данных запрещается использовать `scanf("%s", s)`, если только заданием не гарантируется, что на вход не может быть подана слишком длинная строчка.
* Код должен соблюдать базовые требования стиля (пробелы, однообразные отступы).
