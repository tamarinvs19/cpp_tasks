# Лабораторная №16 (`WW_parallel_sort`)

## Содержание
1. [Содержание](#содержание)
1. [Задание](#задание)
1. [Требования к корректности решения](#требования-к-корректности-решения)
    1. [Стандартные требования](#стандартные-требования)
    1. [Детали реализации](#детали-реализации)
    1. [Структура репозитория](#структура-репозитория)
1. [Сроки сдачи](#сроки-сдачи)
1. [Система оценки](#система-оценки)

## Задание

Требуется реализовать алгоритм параллельной сортировки слиянием, аналогичный написанному в лабораторной работе №4.
Отличие состоит в том, что сортировка участков контейнера производится параллельно, а затем выполняется слияние отсортированных участков.
Сигнатура должна быть аналогична функции `std::sort`, у которой возможны два варианта использования. Сигнатура `parallel_sort`:
```
namespace lab_16 {

template<class RandomIt>
void parallel_sort(std::size_t nthreads, RandomIt first, RandomIt last);

template<class RandomIt, class Compare>
void parallel_sort(std::size_t nthreads, RandomIt first, RandomIt last, Compare comp);

}
```
где
* *RandomIt* — тип итераторов, задающих диапазон для сортировки.
  Гарантируется, что он является *итератором произвольного доступа* и
  [имеет все соотвествующие типы и методы](https://en.cppreference.com/w/cpp/named_req/RandomAccessIterator).
* *Compare* — тип компаратора, задающего порядок для сортировки.
  Гарантируется, что его можно вызвать, передав два элемента (возможно по константной ссылке) и получить `bool`,
  описывающий, в правильном ли порядке лежат элементы.
  Детальнее о требованиях можно прочитать [здесь](https://en.cppreference.com/w/cpp/named_req/Compare).
* *nthreads* — количество потоков, которые необходимо задействовать в сортировке.
* *first* — итератор начала сортируемого диапазона.
* *last* — итератор конца сортируемого диапазона.
* *comp* — компаратор задающий порядок сортировки.

В этом задании также гарантируется, что сортируемый тип имеет
[конструктор по умолчанию](https://en.cppreference.com/w/cpp/named_req/DefaultConstructible),
[деструктор](https://en.cppreference.com/w/cpp/named_req/CopyAssignable) и
[оператор копирования](https://en.cppreference.com/w/cpp/named_req/CopyAssignable).
Обратите внимание, что требования `std::sort` куда более слабые.

Также, в перегрузке без компаратора для сортируемого типа гарантируется наличие
подходящего под требования `operator <` (читайте ниже).

Объявление должно находиться в файле `parallel_sort.hpp`.

## Требования к корректности решения
### Стандартные требования
Смотри стандартные требования из предыдущих заданий (они теперь доступны [в общей папке](../tasks-common)), название папки и файла — `lab_16`.

### Детали реализации
* При подключении файла `parallel_sort.hpp` пользователю становится доступна функция `lab_16::parallel_sort`.
  Остальные функции не должны быть доступны в этом пространстве имён.
* Как и у функции `std::sort`, результат сортировки должен оказаться в заданном на вход диапазоне.
* Для реализации многопоточной версии следует вычислить границы диапазонов,
  каждый поток будет выполнять сортировку собственного участка контейнера в пределах вычисленных границ.
  После завершения частичной сортировки необходимо выполнить слияние отсортированных участков.
* Эффективность разделения на потоки должна быть таковой, чтобы было заметно ускорение работы на двух потоках
  по сравнению с одним потоком на хотя бы 100 000 элементах.
  При увеличении числа потоков до числа ядер вашей машины время должно и дальше уменьшаться.
* Для реализации многопоточности рекомендуется пользоваться `std::thread`.
* Наверняка вам потребуется восстановить из типа итератора тип сортируемого значения.
  Помните о существовании `std::iterator_traits`.
* При решении разрешается и рекомендуется использовать стандартные функции и классы.
  Например, есть стандартная функция слияния.
  **Не разрешается пользоваться стандартными функциями сортировки.**
  Также, есть стандартный компаратор, применяющий `operator <` для всех типов.
  *Примечание: мы не оговариваем тут определённый крайний случай, который этот компаратор решает за вас.*

### Структура репозитория
```
<корень-личного-репозитория>
|--lab_16
   |--include
   |  |-- parallel_sort.hpp
   |  |-- parallel_sort.inl
   |--src
   |  |-- main.cpp
   |--Makefile
```

Папку `obj`, объектные и исполняемые файлы класть в репозиторий не разрешается.

## Бонусное задание

Если задуматься, то, вообще говоря, копировать элементы при сортировке не надо.
В рамках бонусного задания исправьте решение, чтобы вместо копирования сортируемые значения перемещались.

Гарантируется, что сортируемый тип всегда имеет [оператор перемещения](https://en.cppreference.com/w/cpp/named_req/MoveAssignable),
а гарантия на наличие опереатор копирования отозвана.

## Сроки сдачи
Задание выдано 23.04.2020 (четверг).
Крайний срок сдачи — **30.04.2020 (четверг) 22:59 по Москве**.

Также на усмотрение преподавателя могут назначаться дополнительные попытки сдачи и дополнительные сроки
проверки.
Например, преподаватель может оперативно проверить решения, отправленные за несколько дней до дедлайна,
и гораздо медленнее — отправленные перед дедлайном.
Уточняйте у своего преподавателя.

## Система оценки
* Задание оценивается в 10 баллов: 7 за корректность и 3 за стиль. За бонус даётся +1 балл.
* Точные критерии оценки каждой из частей остаются на усмотрение преподавателя.
