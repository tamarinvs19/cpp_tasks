# Лабораторная №17 (`WW_sync_queue`)

## Содержание
1. [Содержание](#содержание)
1. [Задание](#задание)
1. [Требования к корректности решения](#требования-к-корректности-решения)
    1. [Стандартные требования](#стандартные-требования)
    1. [Детали реализации очереди](#детали-реализации-очереди)
    1. [Консольное приложение](#консольное-приложение)
    1. [Рекомендации](#рекомендации)
    1. [Структура репозитория](#структура-репозитория)
1. [Сроки сдачи](#сроки-сдачи)
1. [Система оценки](#система-оценки)

## Задание
Реализуйте потокобезопасную очередь `lab_17::sync_queue`.
Для реализации воспользуйтесь взаимным исключением (_mutex_) и условными переменными  (_condition variables_) 
из стандартной библиотеки C++.

Такие очереди являются частым и весьма полезным примитивом для выстраивания взаимодействия между потоками: они являются 
безопасными буферами сообщений, контроллирующими их избыток или недостаток. Поток, который не может выполнить операцию, 
приостанавливается.

Также реализуйте приложение, позваляющее пользователю задавать задачи фоновому потоку (или нескольким) и наблюдать 
результаты. Общение с потоками-работниками происходит с помощью очереди. Подробнее читайте ниже.

## Требования к корректности решения
### Стандартные требования
Смотри стандартные требования из предыдущих заданий (они теперь доступны [в общей папке](../tasks-common)), название 
папки и файла — `lab_17`.

### Детали реализации очереди
Очередь является шаблонным классом, где парамтер задаёт тип хранимых ею значений.
Сама очередь реализует набор операций для добавления в очередь и доставания из очереди.
Обе операции имеют две вариации: блокирующую (то есть ожидающую возможность успешного выполнения)
и неблокирующую (сигнализирующую о невозможности выполнения без блокировки).

Также, для удобства использования в межпоточном взаимодействии, очередь поддерживает операцию выключения.
После выключения все текущие модифицирующие операции должны быть остановлены, а все новые — запрещены.
Это позволит вывести из ожидания потоки, которые уже не дождутся требуемых условий.

Очередь должна поддерживать следующие методы:
1. Конструктор, принимающий максимальный размер очереди.
   По умолчанию этот размер должен быть максимально возможным значением (неограниченна).
1. Методы для перемещения. Деструктор.
1. `try_push`, который пытается добавлить новый элемент в очередь, если есть место и очередь не выключена.
   Возвращает `bool`: успешность операции.
1. `push`, который добавляет новый элемент в очередь.
   В случае её заполненности ожидает необходимого момента.
   Если операция будет прервана выключением или очередь уже была выключена, надо бросить исключение.
1. `try_pop`, который пытается достать элемент из очереди, если сейчас такой имеется и очередь не выключена.
   Возвращает `std::optional<T>`, содержащий значение, если оно было найдено.
1. `pop`, который достаёт элемент из очереди.
   В случае отсутствия ожидает появления нового элемента.
   Если операция будет прервана выключением или очередь уже была выключена, надо бросить исключение.
1. `size`, который сообщает текущий размер очереди.
1. `shutdown`, выключающий очередь.
   Если очередь уже была выключена, надо бросить исключение.
1. `is_shutdown`, сообщающий, была ли выключена очередь.

Все служебные методы (конструкторы, деструкторы, присваивания) могут расчитывать, что конкурентных операций нет.
Остальные операции с очередью, при этом, должны работать корректно при использовании из многих потоков и гарантировать
отсутствие гонок.
   
Не реализовывайте хранилище элементов самостоятельно, воспользуйтесь стандартным.
Не вдаваясь в подробности, вам гарантируется, что хранимый в очереди тип можно безопасно 
перемещать, а в перегрузках метода `push`, требующих копирования, и копировать.

Очередь должна подключаться из заголовочного файла `sync_queue.hpp`. Заготовка заголовочного файла приложена к заданию.

### Консольное приложение
Для демонстрации очереди реалзиуйте в `main.cpp` приложение `lab_17` для поиска простых чисел.
Поиск будет осуществляться прямым перебором и проверкой каждого числа за O(√n).
Главный поток программы реализует взаимодействие с пользователем, потоки-работники исполняют задачи.
Для этого заведите две очереди: для отправки задач работникам и возвращения результатов главному.

При запуске через параметры передаются число потоков-работников и максимальный размер очереди задач:
```bash
./lab_17 ‹worker threads› ‹queue size›
```
Не ограничивайте очередь результатов, это может привести к взаимной блокировке!

Приложение читает с ввода команды. Каждая представляет из себя строчку, которая начинается с названия команды.
1. `submit ‹id› ‹start› ‹end›`: отправить работникам задание на поиск простых чисел в диапазоне [_start_, _end_) с именем _id_.
   * `id` — строчка из букв латинского алфавита.
   * `start`, `end` — беззнаковые 64-битные числа.
   
   Если место в очереди есть, то операция должна отработать практически мгновенно (точно быстрее, чем за 10мс).
   Иначе разрешается ожидание.
1. `show-done`: вывести все новые (на текущий момент) сообщения о выполненных задачах:
   ```
   Task ‹id› done in ‹time›ms, found ‹count› primes.`
   ```
   * `id` — имя задачи, заданное в `submit`.
   * `time` — время в миллисекундах, которое прошло с момента отправки задания до окончания выполнения.
   * `count` — чисто простых чисел, найденных в заданом диапазоне.
   
   Операция должна отработать практически мгновенно (точно быстрее, чем за 10мс на 10 новых результатов).
1. `quit` — завершает работу, корректно останавливая и дожидаясь потоков.
   
   Даже если есть запущенные задачи, операция должна быть выполнена не больше, чем за 100мс.
1. На неизвестную команду выводите ошибку `Unknown command: ‹command›!`, где `command` — имя команды.
 
После каждой успешно выполненной команды необходимо вывести сообщение `Done in ‹time›ms`, где _time_ — время выполнения команды в миллисекундах.

## Рекомендации

В очереди лучше использовать две условных переменных и уведомлять потоки по одному.

Как проверить базовую работу приложения:
1. Выставите размер очереди в 1, количество работников в 1.
   Отправьте три задания, первое из которых займёт хотя бы 10 секунд, остальные быстрее.
   * Первое должно быть принято мгновенно, потому что очередь пуста.
   * Второе должно быть принято мгновенно, потому что первое должен был сразу забрать работник, и очередь пуста.
   * Третье должно быть принято с задержкой, пока не будет выполнено первое задание и из очереди не заберут второе.
     Значит к моменту принятия первое должно быть сделано.
   
   До, между и после можете посылать `show-done`, чтобы убедиться в происходящем.
   Чуть спустя должны быть сделаны и другие задачи.
1. После этого отправьте одну сверхтяжёлую задачу. Проверьте что она не выполнилась сразу с помощью `show-done`, отправьте `quit`.
   Программа должна довольно быстро выйти.
1. Увеличьте размер очереди. Теперь очередь должна вместить больше задач до начала задержки.
   Учтите, что если задачи слишком простые, то работники будут выполнять их быстрее, чем вы их кладёте.
1. Увеличьте число работников. Теперь задачи после первой должны выполниться до неё за счёт других работников.

### Структура репозитория
```
<корень-личного-репозитория>
|--lab_17
   |--include
   |  |-- sync_queue.hpp
   |--src
   |  |-- main.cpp
   |--Makefile
```

Папку `obj`, объектные и исполняемые файлы класть в репозиторий не разрешается.

## Сроки сдачи
Задание выдано 30.04.2020 (четверг).
Крайний срок сдачи — **14.05.2020 (четверг) 22:59 по Москве**.

Также на усмотрение преподавателя могут назначаться дополнительные попытки сдачи и дополнительные сроки
проверки.
Например, преподаватель может оперативно проверить решения, отправленные за несколько дней до дедлайна,
и гораздо медленнее — отправленные перед дедлайном.
Уточняйте у своего преподавателя.

## Система оценки
* Задание оценивается в 10 баллов: 7 за корректность и 3 за стиль. 
* Точные критерии оценки каждой из частей остаются на усмотрение преподавателя.
